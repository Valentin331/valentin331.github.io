{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About me","text":"<p>Hi! My name is Valentin Kuhari\u0107 and I'm a software engineer from Croatia. I primarily work with web technologies, currently focusing on exploring backend architectures and frameworks in TypeScript and PHP.</p>"},{"location":"#professional-work","title":"Professional work","text":"<p>Most of my professional work includes developing and maintaining web-based solutions for various clients. I have worked on e-commerce platforms, blockchain trading solutions implementing Smart Contracts, the medical industry and more. I've worked on software running primarily on the Node runtime, including backend and frontend codebases. My latest work included managing and developing a backend, frontend and 2 react native codebases. I have also worked on deployment, designing and implementing the deployment architecture on AWS.</p> <p>When working on software I pay equal attention to the general goals, deliverables and estimates of the project as I do to the code itself. During my work I keep close relationship with clients, ensuring everybody has the same idea of the current state of the project and the goals we're all aiming for. I never consider code as a standalone entity, but rather as a resource that enables the team to achieve different goals.</p> <p>My latest work includes exploring backend framework designs on the Node runtime. Currently I'm working on Kamiq, a lightweight, Typescript batteries-included framework for Node.js for building declarative server-side applications with high Express.js interoperability that compiles my findings and ideas into an open-source project. Kamiq is still in development and is intended as a learning project and a tool for exploring software design, not as a production-ready web framework.</p>"},{"location":"#software-tools-i-use","title":"Software tools I use","text":"<p>Some of the software tools I use/used in my career:</p> <ul> <li>Nest.js</li> <li>React</li> <li>Express</li> <li>Nest.js</li> <li>TypeORM</li> <li>Primsa</li> <li>Sequelize</li> <li>Angular</li> <li>React Native</li> </ul>"},{"location":"#im-interested-in","title":"I'm interested in","text":""},{"location":"#electronics","title":"Electronics","text":"<p>I've been tinkering with electronics since I was in my elementary school years. High school curriculum gave me the theoretical knowledge I needed to really get my imagination going, and in 2017 in colaboration with Jakov Petrovi\u0107 we presented our remote-controlled model vehicle with a simplified Rocker-bogie suspension system at FER.</p> <p>Today I continue to work with electronics on small hobby projects, like power-banks or small portable radios.</p>"},{"location":"#geopolitics","title":"Geopolitics","text":"<p>In my free time I love exploring the intricacies of the modern global world. Currently reading Prisoners of geography - ten maps that tell you everything you need to know about global politics by Tim Marshall.</p>"},{"location":"#software-i-use-regularly","title":"Software I use regularly","text":"<ul> <li>Brave</li> <li>VSCode</li> <li>NeoVim</li> <li>Figma</li> <li>Notion</li> <li>Telegram</li> <li>Postman</li> <li>Iterm2</li> </ul>"},{"location":"#hardware","title":"Hardware","text":""},{"location":"#general","title":"General","text":"<ul> <li>Monitor: LG monitor 27UP850-W, IPS, 4K UHD, 60Hz, 5ms, 2xHDMI, DP</li> <li>Keyboard: Logitech MX Mechanical Mini</li> <li>Mouse: Logitech MX Master 3</li> </ul>"},{"location":"#daily-driver","title":"Daily driver","text":"<p>My workhorse is a Macbook Air M1 2020 I use everyday for work and personal stuff. A lightweight, Unix-based powerful laptop with a great battery encapsuled in a robust hardware package.</p>"},{"location":"#pc","title":"PC","text":"<p>For Windows-based work or for occasional gaming, I still use my old but trustworthy PC I have been constantly upgrading since 2009. It has been through a lot, but has never let me down in all these years.</p> <ul> <li>Intel i7 920 OC @ 4.0GHz</li> <li>nVidia GeForce 1070</li> <li>16GB DDR3 RAM</li> <li>700W Power Supply</li> <li>GigaByte motherboard</li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>GitHub</li> <li>LinkedIn</li> <li>DEV</li> </ul>"},{"location":"kamiq/","title":"Kamiq - a Typescript, lightweight, Nest-like, batteries-included web framework","text":""},{"location":"kamiq/#table-of-contents","title":"Table of contents","text":"<ul> <li>Kamiq - a Typescript, lightweight, Nest-like, batteries-included web framework</li> <li>Table of contents</li> <li>1. Prelude</li> <li>\u26a0\ufe0f Disclaimer</li> <li>2. Enough intro - show me the code.</li> <li>2.1. Configuring the server</li> <li>2.2. Example</li> <li>2.3. Controllers and routes<ul> <li>2.3.1. Controllers</li> <li>3.3.2. Routes</li> <li>2.3.3. Parameters</li> <li>2.3.4. Middlewares</li> <li>2.3.5. Guards</li> </ul> </li> <li>2.4. Error handling<ul> <li>2.5. Operations</li> <li>2.6. Kamiq errors</li> </ul> </li> <li>3. Here's the repo</li> <li>4. There is a lot more to do</li> <li>5. Outro</li> </ul>"},{"location":"kamiq/#1-prelude","title":"1. Prelude","text":"<p>On my last job, I was handling a project consisting of a legacy backend + frontend codebase where I was constantly refactoring code - it was either unusable, totally unreadable, or both. To make things even worse, the backend was lacking any structure or goal - it was just code thrown around that somehow managed to work most of the time. In the midst of all the refactoring I found myself slowly adding some architectural elements to the codebase, since it was the only way any new code addition could be maintained later. The codebase didn't even separate the controller logic from service logic!</p> <p>With time, things started to take shape, and all my architectural additions helped made the codebase kind of usable. Since moving away from Express wasn't a choice at the time, but numerous new features constantly asked for some new abstractions and design patterns just to keep things organized, I slowly found myself with a backend project that I tailored to my kind of thinking.</p> <p>In the meantime, I left that job but all those concepts stuck with me, so as a learning project I decided to wrap them in a standalone package that can be used cleanly and simply. I never wrote a package before, but I thought this would be a short, fun and productive endeavour. Here I am sharing it with the world so we can discuss, learn and figure out what makes a good framework together. With that, I present to you: Kamiq!</p>"},{"location":"kamiq/#disclaimer","title":"\u26a0\ufe0f Disclaimer","text":"<p>Before you dive in:</p> <ol> <li>In this post I'll be talking about a personal learning project I've been working on. Expect a half-baked but interesting project and a discussion on what makes a fun to use web framework. </li> </ol>"},{"location":"kamiq/#2-enough-intro-show-me-the-code","title":"2. Enough intro - show me the code.","text":"<p>Short description first:</p> <p>Kamiq is a TypeScript framework for building server-side applications with heavy decorator usage. It combines object-oriented and functional programming approaches to achieve it's minimal syntax design. Kamiq is built on top of Express.js and by design offers high interoperability with Express, enabling the user to easily port over their existing Express.js code including routes, middlewares and more.</p> <p>I'm not treating this project as something I'd like to push through to being complete or production ready - it's merely a learning project and a discussion on node web frameworks in a codebase format. I'm always open to learning new stuff and one of the best ways to learn is to reinvent the wheel, which is what I'm doing here.</p> <p>The following script covers the most important parts of the project and doesn't cover more specific features and possibilities. Check out the full README on the Github repository (link at the end).</p> <p>Right, let's get to it.</p>"},{"location":"kamiq/#21-configuring-the-server","title":"2.1. Configuring the server","text":"<p>To configure your server, instantiate an object from the Server class. Use the public functions to set your configuration object and any other properties.</p> TypeScript<pre><code>import \"reflect-metadata\";\nimport { Server } from \"kamiq\";\nimport { DefaultErrorHandler, DefaultRequestLogger } from \"kamiq/middlewares\";\nimport { SampleController } from \"./controllers/sampleController\";\nconst server = new Server();\nserver.setPort(8001);\nserver.useJsonBodyParser(true);\nserver.useController(SampleController);\nserver.useCors(true);\nserver.setGlobalRequestLogger(new DefaultRequestLogger());\nserver.setGlobalErrorHandler(new DefaultErrorHandler(true));\nserver.start();\n</code></pre>"},{"location":"kamiq/#22-example","title":"2.2. Example","text":"<p>Here's an example of how a controller looks like:</p> TypeScript<pre><code>import { BaseController } from \"kamiq\";\nimport { Middleware, Post, Req, Res } from \"kamiq/decorators\";\nimport { MySampleMiddleware } from \"../middlewares/sampleMiddleware.middleware\";\nimport { MySampleMiddleware2 } from \"../middlewares/sampleMiddleware2.middleware\";\nexport class SampleController extends BaseController {\npath = \"/users\"; // Base path for the following routes.\n@Guard(new AgencyAuthorizer(), {\nignore: true, // Optional way to ignore a guard (or middleware)\n}) // Guards\n@Middleware(new LogSignInEvent(\"user\")) // Middlewares\n@Post(\"/siginin\") // Get controller registeres the route with a GET method and handles errors\nsignIn(\n@Req() req: Request,\n@Res() res: Response,\n@Body() body: IUserSignIn,\n@Param(\"userId\") userId: string\n) {\nconst { password } = body;\nconst signIn = AuthService.signIn(userId, password); // Kamiq operation\nif (signIn.error) throw new AuthorizationError(signIn.error); // Picked up by global err handling middleware\nres.json({ msg: \"success\" });\n}\n}\n</code></pre> <p>Now let's brake it down:</p>"},{"location":"kamiq/#23-controllers-and-routes","title":"2.3. Controllers and routes","text":""},{"location":"kamiq/#231-controllers","title":"2.3.1. Controllers","text":"<p>Controllers are classes that extend the <code>BaseController</code> class. In each controller class you provide the <code>path</code> property - a route prefix for all routes defined in the class.</p>"},{"location":"kamiq/#332-routes","title":"3.3.2. Routes","text":"<p>Each route is a function with the name of your choosing to which a decorator is attached with the HTTP method name: <code>@Get()</code> for a GET method, <code>@Post()</code> for POST etc. An HTTP decorator combined with a handler function forms a route. HTTP method decorators take in a string argument that is the route specific suffix. Note that this also supports dynamic routes by adding parameters to the route, as shown above in the example with <code>:userId</code>.</p>"},{"location":"kamiq/#233-parameters","title":"2.3.3. Parameters","text":"<p>The route handler itself supports multiple decorators that you can inject to get access to various properties of the request lifecycle. Since Kamiq uses Express.js to process HTTP requests, you can inject Express <code>Request</code> and <code>Response</code> objects into the hander like shown above with the <code>@Req()</code> and <code>@Res()</code> decorators. Also, you have access to <code>@Body</code>, <code>@Query()</code>, <code>@Param()</code>, which extract some specific data from the request as shown above.</p>"},{"location":"kamiq/#234-middlewares","title":"2.3.4. Middlewares","text":"<p>Kamiq also supports middlewares, which you can attach to routes by using the <code>@Middleware</code> decorator. Middlewares are classes that extend the <code>KamiqMiddleware</code> interface, which is very similar to Nest's interface where the <code>use()</code> function is really just a vanilla Express.js middleware function.</p> <p>This also has a nice side-effect where middleware functions can be passed arguments which can alter their behaviour. Consider the middleware as shown:</p> TypeScript<pre><code>export class MySampleMiddleware implements KamiqMiddleware {\nprivate readonly someValue: boolean;\nconstructor(someValue: boolean) {\nthis.someValue = someValue;\n}\nasync use(req: Request, res: Response, next: NextFunction): Promise&lt;void&gt; {\n// Can use someValue to change behavior...\nnext()\n}\n}\n// Route\n@Middleware(new MySampleMiddleware(false))\n@Middleware(new MySampleMiddleware2())\n@Post('/users')\ncreateUser(@Req() req: Request, @Res() res: Response) {\n// @ts-ignore\nres.send('user created.')\n}\n</code></pre> <p>Note that if a route has multiple middlewares attached, the order of execution is respected.</p> <p>Middlewares also accept a second argument, an <code>options</code> object where you can specify middleware execution instructions like the ability to bypass execution while testing with the <code>ignore</code> property. </p>"},{"location":"kamiq/#235-guards","title":"2.3.5. Guards","text":"<p>Guards are special type of middlewares that follow the rule of single responsibility by only handlding authorization and authentication logic. They implement an interface similar to the middleware interface but they return a <code>boolean</code> value, corresponds to a successful or a failed operation, where a successful one means the request proceeds to the next middleware in it's lifecycle and a failure results in an authentication error (or a custom error you can define).</p>"},{"location":"kamiq/#24-error-handling","title":"2.4. Error handling","text":"<p>Error handling in routes is hidden in how they are registered on server start. When routes are being registered they are wrapped in an <code>requestErrorHandler</code> middleware which wraps the route handler in a try/catch block. This ensures any error being thrown, by the application or the user, will be caught.</p> <p>Catching errors is now taken care of, but we still need to handle them. Kamiq offers a public function you can access on the server object called <code>setGlobalErrorHandler</code> which takes in a class that implements the <code>KamiqErrorMiddleware</code> interface. This is a wrapper for an express error middleware that you can pass to the function which will register the middleware and process all caught errors. Kamiq provides a default <code>defaultErrorHandler</code> middleware you can use - or of course, you can easily write your own.</p> <p>A <code>BaseError</code> class is included in the package that extends the Node's <code>Error</code>, making it trivial to write your own custom errors. Simply extend the <code>BaseError</code> class, add your own logic and due to the fact that all route handlers are wrapped in a try/catch block, simply throw your custom error anywhere in the handlers:</p> TypeScript<pre><code>@Get('/test')\nping(@Res() res: Response) {\nthrow new CustomAuthError(\"my error message!\")\nres.send('success')\n}\n</code></pre> <p>and Kamiq will handle everything for you.</p>"},{"location":"kamiq/#25-operations","title":"2.5. Operations","text":"<p>Operations are a special function type that aide with inter-layer communication within your codebase. Let's consider a simple backend architecture, consisting of three layers: presentation, service and data-access layer.</p> <p>Errors should be handled at the controller level, making communication between the layers troublesome, considering any logic may error. This also raises the question of how to handle user-invoked errors at sub-controller levels.</p> <p>Any general function can be an Operation by attaching the <code>Operation()</code> decorator to it.</p> <p>Operation functions are general functions that are wrapped in a try/catch block and have an <code>OperationResult</code> return type:</p> TypeScript<pre><code>export type OperationResult&lt;T&gt; =\n| { success: true; data: T }\n| { success: false; error: Error };\n</code></pre> <p>This ensures any <code>Operation</code> function will return an object with the <code>success</code> property set to <code>true</code> if the operation was successful, together with the <code>data</code> property. In case of failure, <code>success</code> will be <code>false</code>, and the <code>error</code> property will be returned, making it very simple for the receiver of the result to conditionally handle errors:</p> TypeScript<pre><code>// Operation function\nclass MyService {\n@Operation\nstatic myOperationFunction() {\nthrow new Error(\"oops!\");\n}\n}\n// Operation receiver\nfunction mockControllerFunction() {\nconst operationResult = MyService.myOperationFunction();\n// handling the result:\nif (operationResult.error) {\n// handle error case (throw the error and it will be caught)\n}\nconst result = operationResult.success;\n// continue...\n}\n</code></pre> <p>Tip: Combine service level functions as Operations with the controller-level error handling to create bulletproof controller-service logic.</p>"},{"location":"kamiq/#26-kamiq-errors","title":"2.6. Kamiq errors","text":"<p>Kamiq offers descriptive, prettified framework-level error handling. If you make any configuration or definition errors at the framework level, Kamiq will throw it's custom error to help you resolve the problem. Here's an example of such error being thrown, invoked due to a misconfigured <code>port</code> variable:</p> Text Only<pre><code>InvalidArgumentError: \n   \u250c Kamiq encountered an error! \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502                                                                         \u2502\n   \u2502                                                                         \u2502\n   \u2502   InvalidArgumentError:                                                 \u2502\n   \u2502   Port must be a number between 1 and 65535. Provided port is 5236203   \u2502\n   \u2502                                                                         \u2502\n   \u2502   Suggestion: Please check your server configuration.                   \u2502\n   \u2502                                                                         \u2502\n   \u2502                                                                         \u2502\n   \u2502                                                                         \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>there's only a few of such errors as of now, but more checks can be easily added.</p>"},{"location":"kamiq/#3-heres-the-repo","title":"3. Here's the repo","text":"<p>You can visit the repository here, or visit the npm page here.</p>"},{"location":"kamiq/#4-there-is-a-lot-more-to-do","title":"4. There is a lot more to do","text":"<p>There's a lot of features I'd like to add, and many bugs I'd like to fix. Many important functionalities are missing, such as:</p> <ol> <li>Handling cookies</li> <li>Handling content types</li> <li>File uploading and management</li> <li>Monitoring</li> <li>Input validation and sanitization</li> <li>Rendering templates</li> <li>Sessions</li> </ol> <p>and more. I'm currently working on these.</p>"},{"location":"kamiq/#5-outro","title":"5. Outro","text":"<p>Thank you for reading this through. I'd like to hear your opinion on this project and can't wait to learn from your ideas and discussions. Check out the repository and feel free to voice your opinions. Enjoy!</p>"},{"location":"open_source/","title":"Open source","text":"<p>A list of my contributions to open source projects:</p> <ol> <li>Kamiq - a lightweight, batteries-included TypeScript framework for Node.js for building declarative server-side applications with high Express.js interoperability. </li> </ol>"}]}