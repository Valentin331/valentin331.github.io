{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About me","text":"<p>Hi! My name is Valentin Kuhari\u0107 and I'm a software engineer from Croatia. I primarily work with web technologies, currently focusing on exploring backend architectures and frameworks in TypeScript and PHP.</p>"},{"location":"#professional-work","title":"Professional work","text":"<p>Most of my professional work includes developing and maintaining web-based solutions for various clients. I have worked on e-commerce platforms, blockchain trading solutions implementing Smart Contracts, the medical industry and more. I've worked on software running primarily on the Node runtime, including backend and frontend codebases. My latest work included managing and developing a backend, frontend and 2 react native codebases. I have also worked on deployment, designing and implementing the deployment architecture on AWS.</p> <p>When working on software I pay equal attention to the general goals, deliverables and estimates of the project as I do to the code itself. During my work I keep close relationship with clients, ensuring everybody has the same idea of the current state of the project and the goals we're all aiming for. I never consider code as a standalone entity, but rather as a resource that enables the team to achieve different goals.</p> <p>My latest work includes exploring backend framework designs on the Node runtime. Currently I'm working on Kamiq, a lightweight, Typescript batteries-included framework for Node.js for building declarative server-side applications with high Express.js interoperability that compiles my findings and ideas into an open-source project. Kamiq is still in development and is intended as a learning project and a tool for exploring software design, not as a production-ready web framework.</p>"},{"location":"#software-tools-i-use","title":"Software tools I use","text":"<p>Some of the software tools I use/used in my career:</p> <ul> <li>Nest.js</li> <li>React</li> <li>Express</li> <li>Nest.js</li> <li>TypeORM</li> <li>Primsa</li> <li>Sequelize</li> <li>Angular</li> <li>React Native</li> </ul>"},{"location":"#im-interested-in","title":"I'm interested in","text":""},{"location":"#electronics","title":"Electronics","text":"<p>I've been tinkering with electronics since I was in my elementary school years. High school curriculum gave me the theoretical knowledge I needed to really get my imagination going, and in 2017 in colaboration with Jakov Petrovi\u0107 we presented our remote-controlled model vehicle with a simplified Rocker-bogie suspension system at FER.</p> <p>Today I continue to work with electronics on small hobby projects, like power-banks or small portable radios.</p>"},{"location":"#geopolitics","title":"Geopolitics","text":"<p>In my free time I love exploring the intricacies of the modern global world. Currently reading Prisoners of geography - ten maps that tell you everything you need to know about global politics by Tim Marshall.</p>"},{"location":"#software-i-use-regularly","title":"Software I use regularly","text":"<ul> <li>Brave</li> <li>VSCode</li> <li>NeoVim</li> <li>Figma</li> <li>Notion</li> <li>Telegram</li> <li>Postman</li> <li>Iterm2</li> </ul>"},{"location":"#hardware","title":"Hardware","text":""},{"location":"#general","title":"General","text":"<ul> <li>Monitor: LG monitor 27UP850-W, IPS, 4K UHD, 60Hz, 5ms, 2xHDMI, DP</li> <li>Keyboard: Logitech MX Mechanical Mini</li> <li>Mouse: Logitech MX Master 3</li> </ul>"},{"location":"#daily-driver","title":"Daily driver","text":"<p>My workhorse is a Macbook Air M1 2020 I use everyday for work and personal stuff. A lightweight, Unix-based powerful laptop with a great battery encapsuled in a robust hardware package.</p>"},{"location":"#pc","title":"PC","text":"<p>For Windows-based work or for occasional gaming, I still use my old but trustworthy PC I have been constantly upgrading since 2009. It has been through a lot, but has never let me down in all these years.</p> <ul> <li>Intel i7 920 OC @ 4.0GHz</li> <li>nVidia GeForce 1070</li> <li>16GB DDR3 RAM</li> <li>700W Power Supply</li> <li>GigaByte motherboard</li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>GitHub</li> <li>LinkedIn</li> <li>DEV</li> </ul>"},{"location":"kamiq/","title":"Kamiq - a Typescript, lightweight, Nest-like, batteries-included web framework","text":""},{"location":"kamiq/#table-of-contents","title":"Table of contents","text":"<ul> <li>Kamiq - a Typescript, lightweight, Nest-like, batteries-included web framework</li> <li>Table of contents</li> <li>1. Prelude</li> <li>\u26a0\ufe0f Disclaimer</li> <li>2. Enough intro - show me the code.</li> <li>2.1. Configuring the server</li> <li>2.2. Example</li> <li>2.3. Controllers and routes<ul> <li>2.3.1. Controllers</li> <li>3.3.2. Routes</li> <li>2.3.3. Parameters</li> <li>2.3.4. Middlewares</li> <li>2.3.5. Guards</li> </ul> </li> <li>2.4. Error handling<ul> <li>2.5. Operations</li> <li>2.6. Kamiq errors</li> </ul> </li> <li>3. Here's the repo</li> <li>4. There is a lot more to do</li> <li>5. Outro</li> </ul>"},{"location":"kamiq/#1-prelude","title":"1. Prelude","text":"<p>On my last job, I was handling a project consisting of a legacy backend + frontend codebase where I was constantly refactoring code - it was either unusable, totally unreadable, or both. To make things even worse, the backend was lacking any structure or goal - it was just code thrown around that somehow managed to work most of the time. In the midst of all the refactoring I found myself slowly adding some architectural elements to the codebase, since it was the only way any new code addition could be maintained later. The codebase didn't even separate the controller logic from service logic!</p> <p>With time, things started to take shape, and all my architectural additions helped made the codebase kind of usable. Since moving away from Express wasn't a choice at the time, but numerous new features constantly asked for some new abstractions and design patterns just to keep things organized, I slowly found myself with a backend project that I tailored to my kind of thinking.</p> <p>In the meantime, I left that job but all those concepts stuck with me, so as a learning project I decided to wrap them in a standalone package that can be used cleanly and simply. I never wrote a package before, but I thought this would be a short, fun and productive endeavour. Here I am sharing it with the world so we can discuss, learn and figure out what makes a good framework together. With that, I present to you: Kamiq!</p>"},{"location":"kamiq/#disclaimer","title":"\u26a0\ufe0f Disclaimer","text":"<p>Before you dive in:</p> <ol> <li>In this post I'll be talking about a personal learning project I've been working on. Expect a half-baked but interesting project and a discussion on what makes a fun to use web framework. </li> </ol>"},{"location":"kamiq/#2-enough-intro-show-me-the-code","title":"2. Enough intro - show me the code.","text":"<p>Short description first:</p> <p>Kamiq is a TypeScript framework for building server-side applications with heavy decorator usage. It combines object-oriented and functional programming approaches to achieve it's minimal syntax design. Kamiq is built on top of Express.js and by design offers high interoperability with Express, enabling the user to easily port over their existing Express.js code including routes, middlewares and more.</p> <p>I'm not treating this project as something I'd like to push through to being complete or production ready - it's merely a learning project and a discussion on node web frameworks in a codebase format. I'm always open to learning new stuff and one of the best ways to learn is to reinvent the wheel, which is what I'm doing here.</p> <p>The following script covers the most important parts of the project and doesn't cover more specific features and possibilities. Check out the full README on the Github repository (link at the end).</p> <p>Right, let's get to it.</p>"},{"location":"kamiq/#21-configuring-the-server","title":"2.1. Configuring the server","text":"<p>To configure your server, instantiate an object from the Server class. Use the public functions to set your configuration object and any other properties.</p> TypeScript<pre><code>import \"reflect-metadata\";\nimport { Server } from \"kamiq\";\nimport { DefaultErrorHandler, DefaultRequestLogger } from \"kamiq/middlewares\";\nimport { SampleController } from \"./controllers/sampleController\";\nconst server = new Server();\nserver.setPort(8001);\nserver.useJsonBodyParser(true);\nserver.useController(SampleController);\nserver.useCors(true);\nserver.setGlobalRequestLogger(new DefaultRequestLogger());\nserver.setGlobalErrorHandler(new DefaultErrorHandler(true));\nserver.start();\n</code></pre>"},{"location":"kamiq/#22-example","title":"2.2. Example","text":"<p>Here's an example of how a controller looks like:</p> TypeScript<pre><code>import { BaseController } from \"kamiq\";\nimport { Middleware, Post, Req, Res } from \"kamiq/decorators\";\nimport { MySampleMiddleware } from \"../middlewares/sampleMiddleware.middleware\";\nimport { MySampleMiddleware2 } from \"../middlewares/sampleMiddleware2.middleware\";\nexport class SampleController extends BaseController {\npath = \"/users\"; // Base path for the following routes.\n@Guard(new AgencyAuthorizer(), {\nignore: true, // Optional way to ignore a guard (or middleware)\n}) // Guards\n@Middleware(new LogSignInEvent(\"user\")) // Middlewares\n@Post(\"/siginin\") // Get controller registeres the route with a GET method and handles errors\nsignIn(\n@Req() req: Request,\n@Res() res: Response,\n@Body() body: IUserSignIn,\n@Param(\"userId\") userId: string\n) {\nconst { password } = body;\nconst signIn = AuthService.signIn(userId, password); // Kamiq operation\nif (signIn.error) throw new AuthorizationError(signIn.error); // Picked up by global err handling middleware\nres.json({ msg: \"success\" });\n}\n}\n</code></pre> <p>Now let's brake it down:</p>"},{"location":"kamiq/#23-controllers-and-routes","title":"2.3. Controllers and routes","text":""},{"location":"kamiq/#231-controllers","title":"2.3.1. Controllers","text":"<p>Controllers are classes that extend the <code>BaseController</code> class. In each controller class you provide the <code>path</code> property - a route prefix for all routes defined in the class.</p>"},{"location":"kamiq/#332-routes","title":"3.3.2. Routes","text":"<p>Each route is a function with the name of your choosing to which a decorator is attached with the HTTP method name: <code>@Get()</code> for a GET method, <code>@Post()</code> for POST etc. An HTTP decorator combined with a handler function forms a route. HTTP method decorators take in a string argument that is the route specific suffix. Note that this also supports dynamic routes by adding parameters to the route, as shown above in the example with <code>:userId</code>.</p>"},{"location":"kamiq/#233-parameters","title":"2.3.3. Parameters","text":"<p>The route handler itself supports multiple decorators that you can inject to get access to various properties of the request lifecycle. Since Kamiq uses Express.js to process HTTP requests, you can inject Express <code>Request</code> and <code>Response</code> objects into the hander like shown above with the <code>@Req()</code> and <code>@Res()</code> decorators. Also, you have access to <code>@Body</code>, <code>@Query()</code>, <code>@Param()</code>, which extract some specific data from the request as shown above.</p>"},{"location":"kamiq/#234-middlewares","title":"2.3.4. Middlewares","text":"<p>Kamiq also supports middlewares, which you can attach to routes by using the <code>@Middleware</code> decorator. Middlewares are classes that extend the <code>KamiqMiddleware</code> interface, which is very similar to Nest's interface where the <code>use()</code> function is really just a vanilla Express.js middleware function.</p> <p>This also has a nice side-effect where middleware functions can be passed arguments which can alter their behaviour. Consider the middleware as shown:</p> TypeScript<pre><code>export class MySampleMiddleware implements KamiqMiddleware {\nprivate readonly someValue: boolean;\nconstructor(someValue: boolean) {\nthis.someValue = someValue;\n}\nasync use(req: Request, res: Response, next: NextFunction): Promise&lt;void&gt; {\n// Can use someValue to change behavior...\nnext()\n}\n}\n// Route\n@Middleware(new MySampleMiddleware(false))\n@Middleware(new MySampleMiddleware2())\n@Post('/users')\ncreateUser(@Req() req: Request, @Res() res: Response) {\n// @ts-ignore\nres.send('user created.')\n}\n</code></pre> <p>Note that if a route has multiple middlewares attached, the order of execution is respected.</p> <p>Middlewares also accept a second argument, an <code>options</code> object where you can specify middleware execution instructions like the ability to bypass execution while testing with the <code>ignore</code> property. </p>"},{"location":"kamiq/#235-guards","title":"2.3.5. Guards","text":"<p>Guards are special type of middlewares that follow the rule of single responsibility by only handlding authorization and authentication logic. They implement an interface similar to the middleware interface but they return a <code>boolean</code> value, corresponds to a successful or a failed operation, where a successful one means the request proceeds to the next middleware in it's lifecycle and a failure results in an authentication error (or a custom error you can define).</p>"},{"location":"kamiq/#24-error-handling","title":"2.4. Error handling","text":"<p>Error handling in routes is hidden in how they are registered on server start. When routes are being registered they are wrapped in an <code>requestErrorHandler</code> middleware which wraps the route handler in a try/catch block. This ensures any error being thrown, by the application or the user, will be caught.</p> <p>Catching errors is now taken care of, but we still need to handle them. Kamiq offers a public function you can access on the server object called <code>setGlobalErrorHandler</code> which takes in a class that implements the <code>KamiqErrorMiddleware</code> interface. This is a wrapper for an express error middleware that you can pass to the function which will register the middleware and process all caught errors. Kamiq provides a default <code>defaultErrorHandler</code> middleware you can use - or of course, you can easily write your own.</p> <p>A <code>BaseError</code> class is included in the package that extends the Node's <code>Error</code>, making it trivial to write your own custom errors. Simply extend the <code>BaseError</code> class, add your own logic and due to the fact that all route handlers are wrapped in a try/catch block, simply throw your custom error anywhere in the handlers:</p> TypeScript<pre><code>@Get('/test')\nping(@Res() res: Response) {\nthrow new CustomAuthError(\"my error message!\")\nres.send('success')\n}\n</code></pre> <p>and Kamiq will handle everything for you.</p>"},{"location":"kamiq/#25-operations","title":"2.5. Operations","text":"<p>Operations are a special function type that aide with inter-layer communication within your codebase. Let's consider a simple backend architecture, consisting of three layers: presentation, service and data-access layer.</p> <p>Errors should be handled at the controller level, making communication between the layers troublesome, considering any logic may error. This also raises the question of how to handle user-invoked errors at sub-controller levels.</p> <p>Any general function can be an Operation by attaching the <code>Operation()</code> decorator to it.</p> <p>Operation functions are general functions that are wrapped in a try/catch block and have an <code>OperationResult</code> return type:</p> TypeScript<pre><code>export type OperationResult&lt;T&gt; =\n| { success: true; data: T }\n| { success: false; error: Error };\n</code></pre> <p>This ensures any <code>Operation</code> function will return an object with the <code>success</code> property set to <code>true</code> if the operation was successful, together with the <code>data</code> property. In case of failure, <code>success</code> will be <code>false</code>, and the <code>error</code> property will be returned, making it very simple for the receiver of the result to conditionally handle errors:</p> TypeScript<pre><code>// Operation function\nclass MyService {\n@Operation\nstatic myOperationFunction() {\nthrow new Error(\"oops!\");\n}\n}\n// Operation receiver\nfunction mockControllerFunction() {\nconst operationResult = MyService.myOperationFunction();\n// handling the result:\nif (operationResult.error) {\n// handle error case (throw the error and it will be caught)\n}\nconst result = operationResult.success;\n// continue...\n}\n</code></pre> <p>Tip: Combine service level functions as Operations with the controller-level error handling to create bulletproof controller-service logic.</p>"},{"location":"kamiq/#26-kamiq-errors","title":"2.6. Kamiq errors","text":"<p>Kamiq offers descriptive, prettified framework-level error handling. If you make any configuration or definition errors at the framework level, Kamiq will throw it's custom error to help you resolve the problem. Here's an example of such error being thrown, invoked due to a misconfigured <code>port</code> variable:</p> Text Only<pre><code>InvalidArgumentError: \n   \u250c Kamiq encountered an error! \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502                                                                         \u2502\n   \u2502                                                                         \u2502\n   \u2502   InvalidArgumentError:                                                 \u2502\n   \u2502   Port must be a number between 1 and 65535. Provided port is 5236203   \u2502\n   \u2502                                                                         \u2502\n   \u2502   Suggestion: Please check your server configuration.                   \u2502\n   \u2502                                                                         \u2502\n   \u2502                                                                         \u2502\n   \u2502                                                                         \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>there's only a few of such errors as of now, but more checks can be easily added.</p>"},{"location":"kamiq/#3-heres-the-repo","title":"3. Here's the repo","text":"<p>You can visit the repository here, or visit the npm page here.</p>"},{"location":"kamiq/#4-there-is-a-lot-more-to-do","title":"4. There is a lot more to do","text":"<p>There's a lot of features I'd like to add, and many bugs I'd like to fix. Many important functionalities are missing, such as:</p> <ol> <li>Handling cookies</li> <li>Handling content types</li> <li>File uploading and management</li> <li>Monitoring</li> <li>Input validation and sanitization</li> <li>Rendering templates</li> <li>Sessions</li> </ol> <p>and more. I'm currently working on these.</p>"},{"location":"kamiq/#5-outro","title":"5. Outro","text":"<p>Thank you for reading this through. I'd like to hear your opinion on this project and can't wait to learn from your ideas and discussions. Check out the repository and feel free to voice your opinions. Enjoy!</p>"},{"location":"node_ts_express_error_handling/","title":"Beginner-friendy guide to error handling in TypeScript, Node.js, Express.js API design","text":""},{"location":"node_ts_express_error_handling/#1-introduction-to-the-topic","title":"1. Introduction to the topic","text":""},{"location":"node_ts_express_error_handling/#11-overview","title":"1.1. Overview","text":"<p>Error handling is pain. You can get pretty far without handling errors correctly, but the bigger the application, the bigger the problems you\u2019re going to face. To really take your API building to the next level, you should tackle the challenge head-on. Error handling is a broad subject, and it can be done in many ways, depending on the application, technologies and more. It\u2019s one of those things that are easy to understand, but hard to fully grasp.</p>"},{"location":"node_ts_express_error_handling/#12-what-well-be-doing","title":"1.2. What we\u2019ll be doing","text":"<p>In this article, we\u2019re going to explain a beginner-friendly way of handling errors in Node.js + Express.js API with TypeScript. We are going to explain what an error is, different types of errors that can crop up and how to handle them in our application. Here are some of the things we\u2019ll be doing in the next chapters:</p> <ul> <li>learning what \u201cerror handling\u201d really is and the types of errors that you\u2019ll encounter</li> <li>learning about the Node.js <code>Error</code> object and how can we use it</li> <li>learning how to create custom error classes and how they can help us develop better APIs and Node applications</li> <li>learning about Express middleware and how to use them to handle our errors</li> <li>learning how to structure the error information and present it to the consumer and developer</li> </ul>"},{"location":"node_ts_express_error_handling/#13-prerequisites","title":"1.3. Prerequisites","text":"<p>DISCLAMER! This article assumes you already know some stuff. Even though this is beginner-friendly, here\u2019s what you should know to get the most out of this article:</p> <ul> <li>working knowledge of Node.js</li> <li>working knowledge of Express.js (routes, middleware and such)</li> <li>basics of TypeScript (and classes!)</li> <li>basics of how an API works and is written using Express.js</li> </ul> <p>Okay. We can begin.</p>"},{"location":"node_ts_express_error_handling/#2-what-is-error-handling-and-why-do-you-need-it","title":"2. What is error handling and why do you need it?","text":"<p>So what exactly is \u201cerror handling\u201d really?</p> <p>Error handling (or exception handling) is the process of responding to the occurrence of errors (anomalous/unwanted behaviour) during the execution of a program. </p> <p>Why do we need error handling?</p> <p>Because we want to make bug fixing less painful. It also helps us write cleaner code since all error handling code is centralized, instead of handling errors wherever we think they might crop up. In the end - the code is more organized, you repeat yourself less and it reduces development and maintenance time.</p>"},{"location":"node_ts_express_error_handling/#3-types-of-errors","title":"3. Types of errors","text":"<p>There are two main types of errors that we need to differentiate and handle accordingly. </p>"},{"location":"node_ts_express_error_handling/#31-operational-errors","title":"3.1. Operational Errors","text":"<p>Operational errors represent runtime problems. They are not necessarily \u201cbugs\u201d, but are external circumstances that can disrupt the flow of program execution. Even though they're not errors in your code, these situations can (and inevitably will) happen and they need to be handled. Here are some examples:</p> <ul> <li>An API request fails for some reason (e.g., the server is down or the rate limit is exceeded)</li> <li>A database connection cannot be established</li> <li>The user sends invalid input data</li> <li>system ran out of memory</li> </ul>"},{"location":"node_ts_express_error_handling/#32-programmer-errors","title":"3.2. Programmer errors","text":"<p>Programmer errors are the real \u201cbugs\u201d and so, they represent issues in the code itself. As mistakes in the syntax or logic of the program, they can be only resolved by changing the source code. Here are some examples of programmer errors:</p> <ul> <li>Trying to read a property on an object that is not defined</li> <li>passing incorrect parameters in a function</li> <li>not catching a rejected promise</li> </ul>"},{"location":"node_ts_express_error_handling/#4-what-is-a-node-error","title":"4. What is a Node error?","text":"<p>Node.js has a built-in object called <code>Error</code> that we will use as our base to throw errors. When thrown, it has a set of information that will tell us where the error happened, the type of error and what is the problem. The Node.js documentation has a more in-depth explanation.</p> <p>We can create an error like this:</p> TypeScript<pre><code>const error = new Error('Error message');\n</code></pre> <p>Okay, so we gave it a string parameter which will be the error message. But what else does this <code>Error</code> have? Since we\u2019re using typescript, we can check its definition, which will lead us to a typescript <code>interface</code>:</p> TypeScript<pre><code>interface Error {\nname: string;\nmessage: string;\nstack?: string;\n}\n</code></pre> <p><code>Name</code> and <code>message</code> are self-explanatory, while <code>stack</code> contains the <code>name</code>, <code>message</code> and a string describing the point in the code at which the\u00a0<code>Error</code>\u00a0was instantiated. This stack is actually a series of stack frames (learn more about it here). Each frame describes a call site within the code that lead to the error being generated. We can <code>console.log()</code> the stack,</p> TypeScript<pre><code>console.log(error.stack)\n</code></pre> <p>and see what it can tell us. Here\u2019s an example of an error we get when passing a string as an argument to the <code>JSON.parse()</code> function (which will fail, since <code>JSON.parse()</code> only takes in JSON data in a string format):</p> <p></p> <p>As we can see, this error is of type SyntaxError, with the message \u201cUnexpected token A in JSON at position 0\u201d. Underneath, we can see the stack frames. This is valuable information we as a developer can use to debug our code and figure out where the problem is - and fix it.</p>"},{"location":"node_ts_express_error_handling/#5-writing-custom-error-classes","title":"5. Writing custom error classes","text":""},{"location":"node_ts_express_error_handling/#51-custom-error-classes","title":"5.1. Custom error classes","text":"<p>As I mentioned before, we can use the built-in <code>Error</code> object, as it gives us valuable information.</p> <p>However, when writing our API we often need to give our developers and consumers of the API a bit more information, so we can make their (and our) life easier.</p> <p>To do that, we can write a class that will extend the <code>Error</code> class with a bit more data.</p> TypeScript<pre><code>class BaseError extends Error {\nstatusCode: number;\nconstructor(statusCode: number, message: string) {\nsuper(message);\nObject.setPrototypeOf(this, new.target.prototype);\nthis.name = Error.name;\nthis.statusCode = statusCode;\nError.captureStackTrace(this);\n}\n}\n</code></pre> <p>Here we\u2019re creating a <code>BaseError</code> class that extends the <code>Error</code> class. The object takes a <code>statusCode</code> (HTTP status code we will return to the user) and a <code>message</code> (error message, just like when creating Node\u2019s built-in <code>Error</code> object).</p> <p>Now we can use the <code>BaseError</code> instead of Node\u2019s <code>Error</code> class to add the HTTP status code.</p> TypeScript<pre><code>// Import the class\nimport { BaseError } from '../utils/error';\nconst extendedError = new BaseError(400, 'message');\n</code></pre> <p>We will use this <code>BaseError</code> class as our base for all our custom errors.</p> <p>Now we can use the <code>BaseError</code> class to extend it and create all our custom errors. These depend on our application needs. For example, if we\u2019re going to have authentication endpoints in our API, we can extend the <code>BaseError</code> class and create an <code>AuthenticationError</code> class like this:</p> TypeScript<pre><code>class AuthenticationError extends BaseError {}\n</code></pre> <p>It will use the same constructor as our <code>BaseError</code>, but once we use it in our code it will make reading and debugging code much easier.</p> <p>Now that we know how to extend the <code>Error</code> object, we can go a step further. </p> <p>A common error we might need is a \u201cnot found\u201d error. Let\u2019s say we have an endpoint where the user specifies a product ID and we try to fetch it from a database. In case we get no results back for that ID, we want to tell the user that the product was not found.</p> <p>Since we\u2019re probably going to use the same logic for more than just Products (for example Users, Carts, Locations), let\u2019s make this error reusable. </p> <p>Let\u2019s extend the <code>BaseError</code> class but now, let\u2019s make the status code default to 404 and put a \u201cproperty\u201d argument in the constructor:</p> TypeScript<pre><code>class NotFoundError extends BaseError {\npropertyName: string;\nconstructor(propertyName: string) {\nsuper(404, `Property '${propertyName}' not found.`);\nthis.propertyName = propertyName;\n}\n}\n</code></pre> <p>Now when using the <code>NotFoundError</code> class, we can just give it the property name, and the object will construct the full message for us (statusCode will default to 404 as you can see from the code).</p> TypeScript<pre><code>// This is how we can use the error\nconst notFoundError = new NotFoundError('Product');\n</code></pre> <p>And this is how it looks when it\u2019s thrown:</p> <p></p> <p>Now we can create different errors that suit our needs. Some of the most common examples for an API would be:</p> <ul> <li>ValidationError (errors you can use when handling incoming user data)</li> <li>DatabaseError (errors you can use to inform the user that there\u2019s a problem with communicating with the database)</li> <li>AuthenticationError (error you can use to signal to the user there\u2019s an authentication error)</li> </ul>"},{"location":"node_ts_express_error_handling/#52-going-a-step-further","title":"5.2. Going a step further","text":"<p>Armed with this knowledge, you can go a step further. Depending on your needs, you can add an <code>errorCode</code> to the <code>BaseError</code> class, and then use it in some of your custom error classes to make the errors more readable to the consumer.</p> <p>For example, you can use the error codes in the <code>AuthenticationError</code> to tell the consumer the type of auth error. <code>A01</code> can mean the user is not verified, while <code>A02</code> can mean that the reset password link has expired. </p> <p>Think about your application\u2019s needs, and try to make it as simple as possible.</p>"},{"location":"node_ts_express_error_handling/#53-creating-and-catching-errors-in-controllers","title":"5.3. Creating and catching errors in controllers","text":"<p>Now let\u2019s take a look at a sample controller (route function) in Express.js</p> TypeScript<pre><code>const sampleController = (req: Request, res: Response, next: NextFunction) =&gt; {\nres.status(200).json({\nresponse: 'successfull',\ndata: {\nanswer: 42\n}\n});\n};\n</code></pre> <p>Let\u2019s try to use our custom error class <code>NotFoundError</code>.  Let\u2019s use the next() function to pass our custom error object to the next middleware function that will catch the error and take care of it (don\u2019t worry about it, I\u2019ll explain how to catch errors in a minute).</p> TypeScript<pre><code>const sampleController = async (req: Request, res: Response, next: NextFunction) =&gt; {\nreturn next(new NotFoundError('Product'))\nres.status(200).json({\nresponse: 'successfull',\ndata: {\nanswer: 42\n}\n});\n};\n</code></pre> <p>This will successfully stop the execution of this function and pass the error to the next middleware function. So, this is it?</p> <p>Not quite. We still need to handle errors we don\u2019t handle through our custom errors.</p>"},{"location":"node_ts_express_error_handling/#54-unhandled-mistakes","title":"5.4. Unhandled mistakes","text":"<p>For example, let\u2019s say you write a piece of code that passes all syntax checks, but will throw an error at runtime. These mistakes can happen, and they will. How do we handle them?</p> <p>Let\u2019s say you want to use the <code>JSON.parse()</code> function. This function takes in JSON data formated as a string, but you give it a random string. Giving this promise-based function a string will cause it to throw an error! If not handled, it will throw an <code>UnhandledPromiseRejectionWarning</code> error.</p> <p></p> <p>Well, just wrap your code inside a try/catch block, and pass any errors down the middleware line using <code>next()</code> (again, I will explain this soon)!</p> <p>And this really will work. This is not a bad practice, since all errors resulting from promise-based code will be caught inside the <code>.catch()</code> block. This has a downside though, and it\u2019s the fact that your controller files will be full of repeated try/catch blocks, and we don\u2019t want to repeat ourselves. Luckily, we do have another ace up our sleeve.</p>"},{"location":"node_ts_express_error_handling/#55-handleasync-wrapper","title":"5.5. handleAsync wrapper","text":"<p>Since we don\u2019t want to write our try/catch blocks in every controller (route function), we can write a middleware function that does that once, and then apply it on every controller.</p> <p>Here\u2019s how it looks:</p> TypeScript<pre><code>const asyncHandler = (fn: any) =&gt; (req: Request, res: Response, next: NextFunction) =&gt; Promise.resolve(fn(req, res, next)).catch(next);\n</code></pre> <p>It may look complicated at first, but it\u2019s just a middleware function that acts as a try/catch block with <code>next(err)</code> inside the <code>catch()</code>. Now, we can just wrap it around our controllers and that\u2019s it!</p> TypeScript<pre><code>const sampleController = asyncHandler(async (req: Request, res: Response, next: NextFunction) =&gt; {\nJSON.parse('A string');\nres.status(200).json({\nresponse: 'successfull',\ndata: {\nsomething: 2\n}\n});\n});\n</code></pre> <p>Now, if the same error is thrown, we won\u2019t get an <code>UnhandledPromiseRejectionWarning</code>, instead, our error handling code will successfully respond and log the error (once we finish writing it, of course. Here\u2019s how it will look like):</p> <p></p> <p></p>"},{"location":"node_ts_express_error_handling/#6-how-do-i-handle-errors","title":"6. How do I handle errors?","text":"<p>Okay, we learned how to create errors. Now what?</p> <p>Now we need to figure out how to actually handle them.</p>"},{"location":"node_ts_express_error_handling/#61-express-middlewares","title":"6.1. Express middlewares","text":"<p>An express application is essentially a series of middleware function calls. A middleware function has access to the <code>request</code> object, the <code>response</code> object, and the <code>next</code> middleware function.</p> <p>Express with route each incoming request through these middlewares, from the first down the chain, until the response is sent to the client. Each middleware function can either pass the request to the next middleware with the next() function, or it can respond to the client and resolve the request.</p> <p>Learn more about Express middleware here.</p>"},{"location":"node_ts_express_error_handling/#62-catching-errors-in-express","title":"6.2. Catching errors in Express","text":"<p>Express has a special type of middleware function called \u201cError-handling middleware\u201d. These functions have an extra argument <code>err</code>. Every time an error is passed in a <code>next()</code> middleware function, Express skips all middleware functions and goes straight to the error-handling ones.</p> <p>Here\u2019s an example on how to write one:</p> TypeScript<pre><code>const errorMiddleware = (error: any, req: Request, res: Response, next: NextFunction) =&gt; {\n// Do something with the error\nnext(error); // pass it to the next function\n};\n</code></pre>"},{"location":"node_ts_express_error_handling/#63-what-to-do-with-errors","title":"6.3. What to do with errors","text":"<p>Now that we know how to catch errors, we have to do something with them. In APIs, there are generally two things you should do: respond to the client and log the error.</p>"},{"location":"node_ts_express_error_handling/#631-errorreponse-middleware-responding-to-the-client","title":"6.3.1. errorReponse middleware (responding to the client)","text":"<p>Personally, when writing APIs I follow a consistent JSON response structure for successful and failed requests:</p> TypeScript<pre><code>// Success\n{\n\"response\": \"successfull\",\n\"message\": \"some message if required\",\n\"data\": {}\n}\n// Failure\n{\n\"response\": \"error\",\n\"error\": {\n\"type\": \"type of error\",\n\"path\": \"/path/on/which/it/happened\",\n\"statusCode\": 404,\n\"message\": \"Message that describes the situation\"\n}\n}\n</code></pre> <p>And now we\u2019re going to write a middleware that handles the failure part.</p> TypeScript<pre><code>const errorResponse = (error: any, req: Request, res: Response, next: NextFunction) =&gt; {\nconst customError: boolean = error.constructor.name === 'NodeError' || error.constructor.name === 'SyntaxError' ? false : true;\nres.status(error.statusCode || 500).json({\nresponse: 'Error',\nerror: {\ntype: customError === false ? 'UnhandledError' : error.constructor.name,\npath: req.path,\nstatusCode: error.statusCode || 500,\nmessage: error.message\n}\n});\nnext(error);\n};\n</code></pre> <p>Let\u2019s examine the function. We first create the <code>customError</code> boolean. We check the <code>error.constructor.name</code> property which tells us what type of error we\u2019re dealing with. If <code>error.constructor.name</code> is <code>NodeError</code> (or some other error we didn\u2019t personally create), we set the boolean to false, otherwise we set it to true. This way we can handle known and unknown errors differently.</p> <p>Next, we can respond to the client. We use the <code>res.status()</code> function to set the HTTP status code and we use the <code>res.json()</code> function to send the JSON data to the client. When writing the JSON data, we can use the <code>customError</code> boolean to set certain properties. For instance, if the <code>customError</code> boolean is false, we will set the error type to \u2018UnhandledError\u2019, telling the user we didn\u2019t anticipate this situation, otherwise, we set it to <code>error.constructor.name</code>.</p> <p>Since the <code>statusCode</code> property is only available in our custom error objects, we can just return 500 if it\u2019s not available (meaning it\u2019s an unhandled error).</p> <p>In the end, we use the <code>next()</code> function to pass the error to the next middleware.</p>"},{"location":"node_ts_express_error_handling/#632-errorlog-middleware-logging-the-error","title":"6.3.2. errorLog middleware (logging the error)","text":"TypeScript<pre><code>const errorLogging = (error: any, req: Request, res: Response, next: NextFunction) =&gt; {\nconst customError: boolean = error.constructor.name === 'NodeError' || error.constructor.name === 'SyntaxError' ? false : true;\nconsole.log('ERROR');\nconsole.log(`Type: ${error.constructor.name === 'NodeError' ? 'UnhandledError' : error.constructor.name}`);\nconsole.log('Path: ' + req.path);\nconsole.log(`Status code: ${error.statusCode || 500}`);\nconsole.log(error.stack);\n};\n</code></pre> <p>This function follows the same logic as the one before, with a small difference. Since this logging is intended for developers of the API, we also log the stack.</p> <p>As you can see, this will just <code>console.log()</code> the error data to the system console. In most production APIs logging is a bit more advanced, logging to a file, or logging to an API. Since this part of the API building is very application-specific, I didn\u2019t want to dive in too much. Now that you have the data, choose what approach works best for your application and implement your version of logging. If you\u2019re deploying to a cloud-based deploying service like AWS, you will be able to download log files by just using the middleware function above (AWS saves all the <code>console.log()</code>s).</p>"},{"location":"node_ts_express_error_handling/#7-you-can-handle-errors-now","title":"7. You can handle errors now.","text":"<p>There you go! That should be enough to get you started with handling errors in a TypeScript + Node.js + Express.js API workflow. Note, there\u2019s a lot of room for improvement here. This approach is not the best, nor the fastest, but is pretty straightforward and most importantly, forgiving, and quick to iterate and improve as your API project progresses and demands more from your skills. These concepts are crucial and easy to get started with, and I hope you\u2019ve enjoyed my article and learned something new.</p> <p>Here's a GitHub repository I made so you can get the full picture: (coming soon) </p> <p>Think I could\u2019ve done something better? Is something not clear? Write it down in the comments.</p> <p>Anyone else you think would benefit from this? Share it!</p> <p>Get in touch: Telegram, Linkedin, Website</p> <p>Thank you \ud83d\ude42</p>"},{"location":"open_source/","title":"Open source","text":"<p>A list of my contributions to open source projects:</p> <ol> <li>Kamiq - a lightweight, batteries-included TypeScript framework for Node.js for building declarative server-side applications with high Express.js interoperability. </li> </ol>"},{"location":"secure_aws_network/","title":"Building a Secure AWS Network: Protecting Instances with Private Subnets","text":""},{"location":"secure_aws_network/#table-of-contents","title":"Table of contents","text":"<ul> <li>Building a Secure AWS Network: Protecting Instances with Private Subnets</li> <li>Table of contents</li> <li>1. Introduction</li> <li>2. Disclaimer</li> <li>2. Introduction to VPCs and deploying a basic instance<ul> <li>2.1. VPCs</li> <li>2.2. CIDR blocks, subnets and security groups</li> <li>2.2.1. CIDR blocks</li> <li>2.2.2. Subnets</li> <li>2.2.3. Security groups</li> <li>2.2.4. Route tables</li> <li>2.2.5. Internet gateway</li> <li>2.2.6. DNS resolution</li> <li>2.3. Setting up a basic deployment</li> <li>2.3.1. Creating the VPC</li> <li>2.3.2. Enabling DNS resolution</li> <li>2.3.3. Creating the subnets</li> <li>2.3.4. Making the subnets public (route tables and Internet gateways)</li> <li>2.3.3. Initial VPC setup</li> <li>2.3.2. Creating our managed backend application</li> <li>2.3.3. Creating our database instance</li> <li>2.3.4. Basic deployment visualisation</li> </ul> </li> <li>3. Challenges of exposing instances to the Internet<ul> <li>3.1. Principle of least privilege</li> <li>3.1.1. Explanation</li> <li>3.1.2. Examples</li> </ul> </li> <li>4. Fixing the mistakes (new architecture)<ul> <li>4.1. Backend: Load-balancing the backend + NAT</li> <li>4.1.1. Approach</li> <li>4.1.2. Creating the subnets</li> <li>4.1.3. Creating and configuring the environment</li> <li>4.1.4. Backend design visualisation</li> <li>4.2. Database: Protecting the database with a jump host + security group access rules</li> <li>4.2.1. Creating subnets</li> <li>4.2.2. Creating the database instance</li> <li>4.2.3. Creating the jump host</li> <li>4.2.4. Connecting to the database</li> <li>4.2.5. Configuring traffic rules<ul> <li>4.2.5.1. Jump host security group</li> <li>4.2.5.2. Database instance security group</li> </ul> </li> <li>4.3. Final architecture visualisation</li> </ul> </li> <li>6. Conclusion</li> </ul>"},{"location":"secure_aws_network/#1-introduction","title":"1. Introduction","text":"<p>This post will cover the problems, scenarios and methods of securing your instances in your AWS deployment using public and private subnets. Specifically it will cover the basics of VPCs (Virtual Private Cloud) and how you can leverage properties of a VPC together with different nodes in your network to secure your vulnerable machines from outside malicious users. We will cover different scenarios that might occur and the problems that arise with some configurations, and what tools we can leverage to create a secure network that minimizes attack surfaces.</p> <p>This post will not cover possible vulnerabilities that might arise from the deployed applications themselves, or architectural issues inside the network, but rather the communcation spaces of different areas and nodes inside the network, and the rules of communication between the Internet and the private network.</p>"},{"location":"secure_aws_network/#2-disclaimer","title":"2. Disclaimer","text":"<p>This post will cover and mention some techniques in computer networks that the reader needs to have a high-level grasp on to follow the article well. Most of the basic concepts mentioned will be explained, and that level of understand is adequate to get the idea of the concepts mentioned but I encourage you to explore the basic ideas before diving into AWS and trying to replicate the deployments. </p> <p>As always, building your architecture one step at a time is more productive and will take less time then trying to have all features right from the get go.</p>"},{"location":"secure_aws_network/#2-introduction-to-vpcs-and-deploying-a-basic-instance","title":"2. Introduction to VPCs and deploying a basic instance","text":"<p>Note</p> <p>Basic knowledge of computer networks is required.</p>"},{"location":"secure_aws_network/#21-vpcs","title":"2.1. VPCs","text":"<p>VPC (Virtual Private Cloud) is a virutal, private network you own via your AWS account. In contrast to real, physical machines, routers and switches it is virtually constructed, but the concepts remain the same. </p> <p>VPCs can be thought as real networks with the same features by which they provide a structured way to deploy your AWS instances. By default, it is a logically isolated network from the Internet and can be thought as a seperate network.</p> <p>The AWS network is a collection of Availability Zones, which are physically represented as data centers. They are interconnected and they form the AWS network. These AZs are then grouped into regions. When we put all this together, we can visually represent the different areas and overlaps like so:</p> <p></p> <p>Visualisation shows a sample AWS region composed of three AZs. Inside the regions we have our private VPC that's spanning across three AZs (we can configure our VPC to reach one or more AZs). Using the internet gateway we can enable communication with the Internet (more on this later). </p>"},{"location":"secure_aws_network/#22-cidr-blocks-subnets-and-security-groups","title":"2.2. CIDR blocks, subnets and security groups","text":""},{"location":"secure_aws_network/#221-cidr-blocks","title":"2.2.1. CIDR blocks","text":"<p>The basic concept of computer networks is that each node in a network is assigned a unique address by which we recognize it as a node. Just as each house in our street has a house number, each node in a computer network has a so-called IP address.</p> <p>Armed with that knowledge, we can represent the scope of our private network as a range of IP addresses. A good analogy would be that in a street we would assign numbers to houses from 20-44, so the same logic would apply to networks - a VPC has a range of IP addresses.</p> <p>Note</p> <p>Basic knowledge of IP addresses is required. Use the following link to learn how IP addresses are comprised.</p> <p>To keep things simple, we'll take only IPv4 addresses into account. Each IPv4 address consists of four 8 bit fields. Meaning the smallest address is 0.0.0.0 and the largest one is 255.255.255.255.</p> <p>This seperation of 4 distinct parts is very useful since we can easily subdevide our total IP range into sections. For example, we can say that some abstract distinct section of our network will have IP address range between 24.24.24.0 and 24.24.24.255. In this case the number of addresses this section has been assigned is 256 addresses.</p> <p>We need a simple, formal way of representing these ranges. Our written example is fine, but we can condense this information into a structured, standardized format that computers can also read.</p> <p>A CIDR block is a notation we can use to represent the IP ranges. Let's take a look at an example of a CIDR block:</p> \\[25.25.25.0/24\\] <p>denotes an IP range from 25.25.25.0 to 25.25.25.255.</p> <p>The \\(/24\\) suffix indicates the count of consecutive leading 1-bits (from left to right) in the network mask. This just means the number of bits that are fixed.</p> <p>Finally, we can now define our private network space with a CIDR block that has 16 static bits. An example would be:</p> \\[192.168.0.0/16\\]"},{"location":"secure_aws_network/#222-subnets","title":"2.2.2. Subnets","text":"<p>So far we have defined our VPC range. Referencing the image of above of defining a sample VPC space, we can notice different \"subnets\" inside the VPC.</p> <p>Subnets are a powerful concept of dividing our network into distinct parts. This is extremely useful since it helps us organize our nodes inside the network. </p> <p>Let us consider an example where we have multiple database nodes and multiple application nodes in our network. We will assign each node in the network it's own rules for accessing other parts of the network. As our network expands this would become exponentially more cumbersome and difficult to manage.</p> <p>Subnets allow us to set and define said rules of communcation and access to a certain range of our network, then all nodes inside the subnet will adhere to said rules. This greatly simplifies managing our nodes.</p>"},{"location":"secure_aws_network/#223-security-groups","title":"2.2.3. Security groups","text":"<p>In addition to subnets, another pivotal aspect of securing our AWS architecture is the implementation of Security Groups. While subnets manage network segmentation, security groups take on the role of controlling inbound and outbound traffic at the instance level. They act as virtual firewalls that regulate the traffic allowed to and from instances associated with them.</p> <p>Security groups operate based on rules that explicitly permit or deny specific traffic flows. These rules can be defined in terms of allowed IP addresses, port ranges, and protocols. Unlike network access control lists (ACLs), which operate at the subnet level, security groups are associated with individual instances.</p> <p>By configuring security groups, you can create a strong defense mechanism to safeguard your instances from unauthorized access and potential security breaches. As you continue to explore the intricacies of AWS security, a comprehensive understanding of both subnets and security groups will be instrumental in designing a well-protected and robust environment for your applications.</p> <p>At this point we have introduced the vital tools of controlling network ranges and assigning communcation rules to those sub-ranges (subnets) and to the individual nodes themselves. Later we will apply these concepts on real world examples to see how to effectively use them to create a secure network.</p>"},{"location":"secure_aws_network/#224-route-tables","title":"2.2.4. Route tables","text":"<p>In the vast networking landscape of AWS, route tables play a central role in directing traffic flow. They contain a set of rules, called routes, that determine how traffic is forwarded between subnets, the internet, and other connected networks.</p> <p>Each subnet in a VPC must be associated with a route table, which dictates the traffic routing for the subnet. A VPC is created with a main route table by default, but additional custom route tables can also be created. When a subnet doesn't have an explicitly associated route table, it falls back to the main route table.</p> <p>Configuring the route table accurately ensures that your network's traffic reaches its intended destination efficiently. For instance, if you want a subnet to communicate with the internet, you would modify the route table associated with that subnet to include a route to an internet gateway.</p>"},{"location":"secure_aws_network/#225-internet-gateway","title":"2.2.5. Internet gateway","text":"<p>An Internet Gateway serves as a critical bridge, enabling communication between resources in your VPC and the internet. It offers a two-way portal: it allows the internet to access your instances (when permitted) and lets your instances access the internet.</p> <p>To facilitate this connectivity, you must attach an Internet Gateway to your VPC and then configure the appropriate route in the associated route table. With this setup, EC2 instances in your VPC can directly communicate with the internet, as long as they have an Elastic IP or Public IP.</p> <p>Remember, while the Internet Gateway paves the way for internet connectivity, the actual accessibility is governed by security groups and network ACLs, ensuring a layered approach to security.</p>"},{"location":"secure_aws_network/#226-dns-resolution","title":"2.2.6. DNS resolution","text":"<p>The Domain Name System (DNS) translates user-friendly domain names (e.g., \"www.example.com\") into IP addresses that machines understand. Within a VPC in AWS, DNS resolution is automatically enabled, allowing instances to resolve domain names to their corresponding IP addresses. When EC2 instances are launched, they are assigned both private and public DNS hostnames, provided they're in a subnet set to assign public IPs. Keeping DNS resolution and hostnames enabled in a VPC is crucial for many applications, especially those dependent on DNS for communication.</p> <p>Warning</p> <p>We have convered these concepts on a high-level and their implementation in a real AWS network are more complicated and introduce various little rules of application. In the later chapters we will create a real deployment and we will cover some of these, but I strongly recommend that you try to create these rules yourself. Be aware that full network configuration contains more rules and concepts.</p>"},{"location":"secure_aws_network/#23-setting-up-a-basic-deployment","title":"2.3. Setting up a basic deployment","text":"<p>Let's create a simple deployment containing a database and a backend application.</p>"},{"location":"secure_aws_network/#231-creating-the-vpc","title":"2.3.1. Creating the VPC","text":"<p>We'll ignore the default VPC and create our own. We'll set our CIDR block as 24.24.0.0/24 as shown on the image below.</p> <p></p>"},{"location":"secure_aws_network/#232-enabling-dns-resolution","title":"2.3.2. Enabling DNS resolution","text":"<p>Enable DNS resolution and DNS hostnames in the VPC settings.</p> <p></p> <p></p>"},{"location":"secure_aws_network/#233-creating-the-subnets","title":"2.3.3. Creating the subnets","text":"<p>After creating the VPC we'll create just one public subnet where our instances will live. We'll use CIDR block 24.24.1.0/24.</p> <p></p>"},{"location":"secure_aws_network/#234-making-the-subnets-public-route-tables-and-internet-gateways","title":"2.3.4. Making the subnets public (route tables and Internet gateways)","text":"<p>By default, all created subnets are private since they don't have access to the Internet. This is due to the default route table, which sets the rules for communcation for the subnet.</p> <p>Firstly, let's create an Internet Gateway and assign it to our VPC.</p> <p></p> <p></p> <p></p> <p>Now our VPC has access to traffic from the Internet.</p> <p>Create a new route table. We will associate this route table with the subnets we want to make public, so let's set the ruleset to the following traffic rules:</p> <ol> <li>Access to all space inside VPC</li> <li>Access to the internet gateway</li> </ol> <p></p> <p></p> <p>Now the nodes inside the subnet can access traffic from the Internet.</p>"},{"location":"secure_aws_network/#233-initial-vpc-setup","title":"2.3.3. Initial VPC setup","text":"<p>So far, we have the following configuration:</p> <p></p>"},{"location":"secure_aws_network/#232-creating-our-managed-backend-application","title":"2.3.2. Creating our managed backend application","text":"<p>Now let's create our managed backend instances. The node itself that will live in our VPC is a Linux EC2 instance, but we will use Elastic Beanstalk service to manage our instances.</p> <p>Note</p> <p>Elastic Beanstalk is an AWS service for managing and configuring various other AWS services, mainly used to orchestrate Linux machines. Learn more about it here.</p> <p>Select the prefered platform, in this case Node will be used.</p> <p>We'll configure it to deploy our instances inside our public subnet. Make sure to select the proper VPC and subnet. Since we'll directly serve traffic to our instance, make sure to check the Public IP address box to assign a public IP to our instance.</p> <p> </p> <p>After finishing the configuration wizard, Elastic Beanstalk will spin up and configure our instances. Find the URL in the environment details screen to access the application.</p> <p></p> <p>This is how the web page should look like:</p> <p></p> <p>Warning</p> <p>You may possibly encounter an issue while deploying the envoriment with misconfigured service roles. Take a look at this link for more information. Dont forget to select the instance profile!</p>"},{"location":"secure_aws_network/#233-creating-our-database-instance","title":"2.3.3. Creating our database instance","text":"<p>To demonstrate a basic deployment of a database, we will deploy an instance running a a relational database software. AWS provides a service for doing exactly that, called RDS (Relational Database Service). RDS wizard requires that RDS instances live in a subnet spread across two availability zones. Specifically we're required to create a subnet group.</p> <p>So far we have created only one public subnet. Navigate to the VPC service and creat another public subnet. Make sure it's placed in a different AZ compared to the first public subnet! Now that we have two public subnets in different AZs, navigate to RDS service and create a database subnet group that includes these two subnets.</p> <p>Warning</p> <p>Remember to assign the correct route table to the subnet, otherwise no traffic from the Internet can pass through to the instance.</p> <p></p> <p></p> <p>Now we're ready to finally create our database instance. Navigate to the RDS service and launch the instance creation wizard. Make sure to properly configure the connectivity settings, including the correct VPC and subnet group. Make sure to check enable Public access.</p> <p>Note</p> <p>For testing purposes I recommend using the free tier preset for instance class and storage.</p> <p> </p>"},{"location":"secure_aws_network/#234-basic-deployment-visualisation","title":"2.3.4. Basic deployment visualisation","text":"<p>So far, we have created the following configuration:</p> <p></p>"},{"location":"secure_aws_network/#3-challenges-of-exposing-instances-to-the-internet","title":"3. Challenges of exposing instances to the Internet","text":"<p>Our current deployment is valid and works. But when we're designing a system for a production application we must always take security into account. With enough traffic we will eventually encounter malicious users and minimizing potential security risks is a must.</p>"},{"location":"secure_aws_network/#31-principle-of-least-privilege","title":"3.1. Principle of least privilege","text":""},{"location":"secure_aws_network/#311-explanation","title":"3.1.1. Explanation","text":"<p>The Principle of Least Privilege (PoLP) dictates that in a computing environment, all nodes, modules, processes, users, or programs should have access only to the precise information required to execute their tasks. By confining privileges and access rights, we inherently limit the potential vulnerabilities of our system. This is a very powerful concept for minimizing possible attack surfaces our system design might leave open.</p> <p>Imagine a network comprising several nodes. If an attacker compromises one node, the extent of their reach largely depends on the privileges associated with that node.  Considering the principle of least privilage and applying it to our network, the intruder's access is limited, since they can potentially have access to a minimal amount of information in our network, as opposed to the scenario where nodes have unrestricted access, granting the attacker access tothe entirety of our network.</p> <p>This idea can be taken as far as you want, for instance specify rules for read-only or write-only action.</p>"},{"location":"secure_aws_network/#312-examples","title":"3.1.2. Examples","text":"<p>User Accounts on Operating Systems: On most operating systems, there are user accounts with varying privileges. Typically, there are administrator accounts with full system access and standard user accounts with limited access. If a standard user account is compromised, the attacker can't make system-wide changes. This limitation is due to PoLP; the standard account only has the necessary privileges to run applications and not to modify system settings.</p> <p>Database Management: In a database system, not all users need the ability to edit or delete tables. Some might only require read-only access, while others might need more comprehensive permissions for data entry. By tailoring access to individual roles, you can ensure that even if a read-only account gets compromised, the attacker cannot alter the database's data or structure.</p> <p>Web Applications: Consider a web application where users can view, post, and edit content. While every user can view posts, perhaps only the original poster can edit or delete their own content. Implementing PoLP ensures that even if a user's session is hijacked, the malicious actor can only affect the content associated with that specific user and not content from other users.</p>"},{"location":"secure_aws_network/#4-fixing-the-mistakes-new-architecture","title":"4. Fixing the mistakes (new architecture)","text":"<p>So far we have created a working deployment and we have explained the security risks associated with it. Now we'll introduce new concepts in computer networking and apply them to create a secure environment for our applications. We will be sticking to an example of an application deployment and a database deployment.</p>"},{"location":"secure_aws_network/#41-backend-load-balancing-the-backend-nat","title":"4.1. Backend: Load-balancing the backend + NAT","text":""},{"location":"secure_aws_network/#411-approach","title":"4.1.1. Approach","text":"<p>Our current deployment consists of a Linux machine with a public IP, directly accessible from the internet. We aim to enhance its security by placing it within a private network. Instead of direct access, we'll introduce a gatekeeper - in our case, a load balancer  - that mediates communication between the internet and our private machine.</p> <p>We'll set up an Elastic Beanstalk environment to launch machines in a private subnet running our sample Node application. Through the configuration settings, we'll ensure the environment is load-balanced, with the load balancer situated in a public subnet. This setup allows the load balancer to be the public entry point, directing traffic to our private infrastructure. Although the EC2 instances are in a private subnet, they still need internet access for updates. To accommodate this, we'll associate them with a NAT gateway in the private subnet, allowing only incoming traffic.</p> <p>Tip</p> <p>Learn more about load balancers here.</p> <p>Tip</p> <p>Learn more about NAT gateways and how they work here.</p>"},{"location":"secure_aws_network/#412-creating-the-subnets","title":"4.1.2. Creating the subnets","text":"<p>To create our architecture, we need two public subnets for our load balancer. Create two appropriately names public subnets with the method shown in this article. We will also need one private subnet for our application EC2 instances, so create one private subnet.</p> <p>Create a NAT gateway and add it to the private subnet.</p> <p></p>"},{"location":"secure_aws_network/#413-creating-and-configuring-the-environment","title":"4.1.3. Creating and configuring the environment","text":"<p>Once the subnets are ready to go, navigate to Elastic Beanstalk and launch the environment creation wizard. Choose the environment name and configure the environment:</p> <ol> <li>Choose a sample Node app as the desired platform</li> <li>In the networking settings:</li> <li>Choose your VPC</li> <li>Choose the desired private subnet</li> <li>Choose the appropriate security group</li> <li>In the Instance traffic and scaling:</li> <li>Choose the environment type as load balanced</li> <li>Set the load balancer as public</li> <li>Select the load balancer public subnets created earlier</li> </ol> <p>The Elastic Beanstalk wizard will do the rest. After a successfull launch, the application should be accessible via the EB public URL.</p> <p>Info</p> <p>The mentioned configuration may take a substantial time to launch (10 minutes or more). Be patient.</p>"},{"location":"secure_aws_network/#414-backend-design-visualisation","title":"4.1.4. Backend design visualisation","text":""},{"location":"secure_aws_network/#42-database-protecting-the-database-with-a-jump-host-security-group-access-rules","title":"4.2. Database: Protecting the database with a jump host + security group access rules","text":""},{"location":"secure_aws_network/#421-creating-subnets","title":"4.2.1. Creating subnets","text":"<p>Firstly, let's create the private subnets for the database. We need at least two. In this case we'll them private-db-subnet-1 and private-db-subnet-2 and assign IPv4 CIDR blocks of \\(24.24.2.0/24\\) and \\(24.24.3.0/24\\).</p> <p>Warning</p> <p>Make sure the subnets have different Availability zones.</p> <p>Then create the subnet group for the new database instance, consisting of these two subnets.</p> <p>We'll need a public instance for our jump host, which we'll cover shortly. Create a public instance following the method shown earlier. Consider naming it appropriately, in this case we'll choose the name public-db-jump-host-subnet-1.</p>"},{"location":"secure_aws_network/#422-creating-the-database-instance","title":"4.2.2. Creating the database instance","text":"<p>Create an RDS instance in your VPC and set the correct subnet group. At this point, the RDS instance will launch but it won't be accessible since it lives in private subnet space. We will make it accessible from the Internet via a jump host.</p>"},{"location":"secure_aws_network/#423-creating-the-jump-host","title":"4.2.3. Creating the jump host","text":"<p>Note</p> <p>A jump host configuration is not an ideal approach, but it's a great learning example to grasp different traffic rules and the idea of protecting network instances. It is a potential point of vulnerability as it's exposed to the internet. It's crucial to harden its security, apply timely patches, and follow best practices to minimize risks.</p> <p>A jump host (or bastion host) is a special-purpose node (computer, virutal machine) in a computer network configured to withstand attacks and act as a gateway to access resources inside a private network from the external world. </p> <p>In this context, we'll utilize the jump host as a bridge to connect to our RDS instance situated in a private subnet.</p> <p>We'll configure our jump host as a Linux machine using the EC2 service. We'll launch a simple EC2 instance in the public subnet, exposed to the Internet. By configuring the SSH keys an outside user will be able to securely connect to a public node in our network, from which they'll be able to access protected nodes.</p> <p>Note</p> <p>Basic knowledge of SSH cryptographic protocol is required. Learn the basics here.</p> <p>Let's create a Linux machine with EC2. </p> <ol> <li>Choose instance name</li> <li>Use Amazon Linux 2023 64-bit image or newer</li> <li>Choose t3.micro instance type (free tier eligible)</li> <li>Create a new key pair for login (by creating a new pair, the browser will prompt you to download the key)</li> <li>Configure the network settings</li> <li>Select your VPC</li> <li>Select the jump host public subnet as the desired subnet</li> <li>Set Auto-assign public IP to Enable</li> <li>Make sure the wizard assigns a new security group tp the instance by selecting the option Create security group</li> <li>Make sure the inbound security group rules allow SSH traffic on port 22 from anywhere (more on this later)</li> <li>Submit the form</li> </ol> <p>Now the EC2 instance should boot up within a couple of minutes.</p>"},{"location":"secure_aws_network/#424-connecting-to-the-database","title":"4.2.4. Connecting to the database","text":"<p>Now our jump host and database should be properly configured for the outside user to gain access via the secure node. To connect to the database the user can SSH into the secure node like so:</p> Text Only<pre><code>ssh ec2-user@&lt;MACHINE IP ADDRESS&gt; -i &lt;PATH_TO_PRIVATE_KEY&gt;\n</code></pre> <p>with the desired output:</p> Text Only<pre><code>   ,     #_\n   ~\\_  ####_        Amazon Linux 2023\n  ~~  \\_#####\\\n  ~~     \\###|\n  ~~       \\#/ ___   https://aws.amazon.com/linux/amazon-linux-2023\n   ~~       V~' '-&gt;\n    ~~~         /\n      ~~._.   _/\n         _/ _/\n       _/m/'\nLast login: Mon Aug 21 12:54:33 2023 from &lt;REMOTE USER IP&gt;\n[ec2-user@ip-&lt;VPC PRIVATE NETWORK IP&gt; ~]$ \n</code></pre> <p>This confirms correct configuration of the jump host.</p> <p>Tip</p> <p>For .pem files used for SSH access, you should set the permissions to be read-only by the owner. This ensures that the private key remains confidential and isn't accidentally modified.</p> <p>You can set the correct permissions using the <code>chmod</code> command:</p> Text Only<pre><code>chmod 400 /path/to/your_key.pem\n</code></pre> <p>To securely access a database on a remote machine without exposing it directly, we can create an SSH tunnel. This technique involves forwarding a local port on your machine to a port on the remote database server, essentially making the database accessible as if it were running locally.</p> <p>The command for setting up this SSH tunnel is:</p> Text Only<pre><code>ssh -L _LOCAL_PORT_:_REMOTE_DATABASE_HOST_:_REMOTE_DATABASE_PORT_ _JUMP_HOST_USERNAME_@_JUMP_HOST_PUBLIC_IP_ -i _PATH_TO_PRIVATE_KEY_\n</code></pre> <ul> <li>LOCAL_PORT: A free port on your local machine.</li> <li>REMOTE_DATABASE_HOST: The hostname or IP address where the database resides.</li> <li>REMOTE_DATABASE_PORT: The port the database listens to.</li> <li>JUMP_HOST_USERNAME: Username associated with the jump (or bastion) host.</li> <li>JUMP_HOST_PUBLIC_IP: The jump host's public IP address.</li> <li>PATH_TO_PRIVATE_KEY: Directory path to the SSH private key for authentication.</li> </ul> <p>After setting up the SSH tunnel, connect to the database using your desired database tool or API as if it's on your local machine. Access it at <code>localhost:_LOCAL_PORT_</code>.</p>"},{"location":"secure_aws_network/#425-configuring-traffic-rules","title":"4.2.5. Configuring traffic rules","text":"<p>We have demonstrated how to protect a private database instance by not exposing it to the Internet directly, but rather provide access via a jump host. This is a huge improvement from the original design but there is still room to improve. We will be specfically focusing on security group rules for the jump host and the database to futher comply with the Principle of least privilege.</p>"},{"location":"secure_aws_network/#4251-jump-host-security-group","title":"4.2.5.1. Jump host security group","text":"<p>Let's navigate to EC2, select the jump host, and review its security group.</p> <p>So far, the jump host listens only for SSH traffic, which is the desired behavior. The potential security risk is that any user, from anywhere in the world, can attempt to connect to the jump host, denoted by the \\(0.0.0.0/0\\) source rule. While SSH itself is secure, limiting the source addresses can significantly reduce the risk of brute-force attacks. Our current outbound rules allow an attacker to potentially reach other parts of the network.</p> <p>For inbound rules:</p> <ol> <li>Limit Source: Tighten the inbound rules by allowing only trusted IP addresses, such as your company's VPN, specific employee IP addresses, or other controlled networks. This minimizes the exposure to potential attackers by narrowing down the list of IPs that can initiate a connection.</li> </ol> <p>For outbound rules:</p> <ol> <li> <p>Limit Destination: Outbound traffic from the jump host should be restricted to the necessary destinations. Specifically, it should be able to communicate only with the private IP address of the database instance and any other essential services. This configuration ensures that even if the jump host is compromised, the attacker can't use it as a platform to target other unrelated resources or systems.</p> </li> <li> <p>Specify Port: While the jump host primarily serves as a bridge to the database, ensure that it's only allowed to communicate on the specific port your database listens on. This minimizes potential misuse of the jump host.</p> </li> </ol>"},{"location":"secure_aws_network/#4252-database-instance-security-group","title":"4.2.5.2. Database instance security group","text":"<p>Let's navigate to RDS, select our database instance, and review its associated security group rules:</p> <p>For inbound rules:</p> <ol> <li>Limit Source: By default, avoid having a wide-open $0.0.0.0/0 source rule. Instead, only allow inbound traffic from trusted sources. The primary source should be the jump host's private IP, ensuring direct connectivity only through the jump host. Depending on your setup, you might also consider connections from other essential components or services. Specify Port: Ensure that only the specific port your database is listening on is open. This further reduces potential vulnerabilities.</li> </ol> <p>For outbound rules:</p> <ol> <li> <p>Limit Destination: Your database instance should have a limited scope for outbound connections. It's best to only allow the necessary communication, which might include connecting to specific services or updates. Restricting the outbound traffic ensures that data can't be unexpectedly exfiltrated.</p> </li> <li> <p>No Wildcard Rules: Avoid using wildcard rules that allow the database to connect to any IP on any port. Remember, you want to ensure that if your database were ever compromised, its potential to do harm is restricted.</p> </li> </ol>"},{"location":"secure_aws_network/#43-final-architecture-visualisation","title":"4.3. Final architecture visualisation","text":""},{"location":"secure_aws_network/#6-conclusion","title":"6. Conclusion","text":"<p>Securing cloud deployments is an intricate task that requires methodical planning and execution. Throughout this guide, we've taken a dive into some foundational steps for improving the security of AWS Elastic Beanstalk and RDS instances. By placing our EB instances in private subnets, harnessing load balancers in publicly accessible spaces, and adding an additional layer of protection to our RDS databases with a jump host, we've made significant strides in fortifying cloud deployments on AWS.</p> <p>However, it's essential to understand that this is merely an introductory guide. Real-world production environments often demand a myriad of additional techniques, strategies, and concepts to ensure comprehensive protection such as firewall configurations, intrusion detection systems, monitoring and incident response mechanisms.</p> <p>We have layed a strong foundation, but the battle is ongoing and there are always new methods and concepts to be learned and implemented. The tools and techniques one should use are determined by the requirements themselves.</p> <p>The following configuration is a great starter guide for understanding basic network principles and how to begin designing an application deployment on AWS. By incoprorating more advances techniques one can create a production-ready environment faster then ever before. I hope you found this guide enlightening. Best of luck on your AWS journey!</p>"},{"location":"blog/","title":"Blog posts","text":"<p>A list of my blog posts:</p> <ol> <li>Building a Secure AWS Network: Protecting Instances with Private Subnets</li> <li>Beginner-friendy guide to error handling in TypeScript, Node.js, Express.js API design</li> <li>Kamiq - a Typescript, lightweight, Nest-like, batteries-included web framework</li> </ol>"}]}